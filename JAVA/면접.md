# 면접 준비하면서 자바 프로그램 알아보기

https://dev-coco.tistory.com/153

## Java의 특징 
Java는 객체지향 프로그래밍 언어


기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡,상,추,다 잘 적용된 언어임

장점
- JVM(자바가상머신) 위에서 동작하기 때문에 운영체제가 독립적
- GC를 통한 자동적인 메모리 관리가 가능

단점
- JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느림
- 다중 상속이나 타입에 엄격하며 제약이 많다.

## JVM의 역할에 대해 설명
[JVM](https://github.com/Hoonyyyy/JAVA-or-Spring/blob/main/JAVA/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84%ED%95%98%EB%A9%B4%EC%84%9C.md) 은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주는 역할을 하고 GC를 통해 ***자동적인*** 메로리 관리를 해줌

## Java의 컴파일 과정에 대해 설명
1. 개발자가 Java 파일을 생성
2. build
3. Java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성
4. Class Loader를 통해 JVM 메모리 내로 로드
5. 실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석 (각 운영체제에 맞는 기계어)

## Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나?
정수형 byte, short, int, long 실수형 float, double 문자형 char 논리형 boolean이 있고,

정수형 1, 2, 3, 4 문자형 2, 논리형 1 바이트를 차지

## 오버로딩과 오버라이딩 설명
오버로딩 : 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말함

오버라이딩 : 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말함

## OOP(object oriented programming 설명
우리가 실생활에서 쓰는 모든 것을 객체라 하며, 객체 지향 프로그래밍은 구현에 필요한 객체를 파악하고

상태와 행위를 가진 객체를 만들고 각자 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말함

즉, 기능이 아닌 ***객체가 중심***이며 ***누가 어떤 일을 할 것인가***가 핵심

특징 : 캡,상,추,다 모듈 재사용으로 확장 및 유지보수가 용이함

## try-with-resources
try-with-resources는 try-catch-finally의 문제점 보완하기 위해 나온 개념

try(...) 안에 자원 객체를 전달하면, try블록이 끝나고 자동으로 자원 해제 해주는 기능을 말함

따로 finally 구문이나 모든 catch 구문에 종료 처리를 하지 않아도 되는 장점이 있음

## 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명
불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말함

Java에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고,

참조 타입일 경우에는 추가적인 작업이 필요함

[원시값 참조값 정리](https://github.com/Hoonyyyy/JAVA-or-Spring/blob/main/JAVA/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84%ED%95%98%EB%A9%B4%EC%84%9C.md)

## 불변객체가 참조타입일 경우 추가적인 작업이 어떤게 있는지 설명
참조 타입은 대표적으로 1. 객체를 참조할 수도 있고 2. Array 3.List를 참조할 수 있음

1. 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 함
2. 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 됨 (배여를 그대로 참조,반환하면 외부에서 내부값 변경할 수 있음 그렇기에 clone해서 외부값 변경못하게해야함)
3. List인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야함
4. Array와 List는 내부를 복사하여 전달하는데, 이를 방어적 복사(defensive-copy)라고 함

## 불변객체나 final을 굳이 사용해야 하는 이유가 있나?
불변 객체나 final 키워드를 사용해 얻는 이점은 다음과 같다.
1. Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 됨

  (공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 떄문)

2. 실패 원자적인 메소드를 만들 수 있음

  (어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능)

3. 부수효과를 피해 오류를 최소화

  (부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상)

4. 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있음

5. 가비지 컬렉션 성능을 높일 수 있음

  (가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 gc 수행 시 지연시간도 줄어듬)

## 추상클래스와 인터페이스를 설명해주시고, 차이에 대해 설명
__추상클래스__는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말함

__인터페이스__는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말함

공통점
- new 연산자로 인스턴스 생성 불가능
- 사용하기 위해서는 하위 클래스에서 확장/구현 해야 함

차이점
- 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하는 강제함이 있음
- 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용
- 다중 상속 : 인터페이스 o, 추상클래스 x

## 싱글톤 패턴에 대해 설명
싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴

인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우

동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용 (메모리 낭비 방지)

ex) Spring Bean

## 가비지 컬렉션(Garbage Collection)에 대해 설명
가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서

필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법

## GC 과정
1. JVM이 어플리케이션의 실행을 잠시 멈춤
2. GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 (Stop The Wolrd) 사용하지 않는 메모리를 제거(Mark and Sweep 과정)
3. 작업이 재개

## 객체지향의 설계 원칙
- SRP(단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야함
- OCP(개방-폐쇄 원책) : 확장에는 열려있고, 수정에는 닫혀야함
- LSP(리스코프 치환 원칙) : 상위 타입은 항상 하위 타입으로 대체할 수 있어야 함
- ISP(인터페이스 분리 원칙) : 인터페이스 내에 메소드는 최소한 일수록 좋음 (하나의 일반적인 인터페ㅣ스보단 여러개의 구체적인 인터페이스가 낫다.) SRP와 같은 문제에 대한 두가지 다른 해결책
- DIP(의존관계 역전 원칙) : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺기, DIP 원칙 가장 인기 있는 방법 DI(의존성주입)

## 자바 메모리 영역에 대해 설명
- Method : 전역변수, static변수를 저장하며, Method영역은 프로그램의 시작부터 종료까지 메모리에 남아있음
- Heap : ***new 키워드*** 로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, GC에 의해 메모리가 관리됨
- Stack : 지역변수와 매개변수 데이터 값이 저장되는 공간, 메서드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제 LIFO(Last In First Out) 구조를 갖고 변수에 새로운 데이터 할당되면 이전 데이터는 지워짐

## 메모리 언제 할당되나?
- Method : JVM이 동작해서 클래스가 로딩될 때 생성
- Heap : 런타임시 할당
- Stack : 컴파일 타임 시 할당

## 클래스와 객체에 대해 설명
클래스
- 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용

객체
- 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 가짐
- 여기서 상태는 필드(Fields), 행동은 메서드(Method)라고 표현

객체에 메모리가 할당되어 실제로 활용되는 실체는 '***인스턴스***' 라고 부름

## 생성자(Constructor)에 대해 설명
생성자는 클래스와 같은 이름의 메서드로, 객체가 생성될 때 호출되는 메서드

명시적으로 생성자를 만들지 않아도 default로 마들어지며, 생성자는 파라미터를 다르게하여 '***오버로딩***' 할 수 있음

## Wrapper Class란 무엇이며, Boxing과 UnBoxing은 무엇인지 설명
기본 자료형(Primitive data type)에 대한 객체 표현을 Wrapper class라고 함

기본 자료형 -> Wrapper class로 변환하는 것을 Boxing이라 함

Wrapper class -> 기본 자료형 변환하는 것을 UnBoxing이라 함

## Synchronized?

여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념

데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장

Synchronized는 변수와 메서드에 사용해서 동기화 할 수 있으며, Synchronized 키워드를 남발하게 되면 오히려 프로그램의 성능저하를 일으킴

## new String()과 리터럴("")의 차이에 대해 설명
- new string() new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장
- ""는 ***Heap*** 안에 있는 String Constant Pool 영역에 저장됨

## String, StringBuffer, StringBuilder의 차이 설명
- String은 불변의 속성, Buffer & Builder는 가변의 속성을 가짐 , 문자열 연산 적고 && 멀티쓰레드 환경일 경우
- Buffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용 , 문자열 연산 많고 && 멀티쓰레드 환경일 경우
- Builder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용 , 문자열 연산이 많고 && 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우

## String 객체가 불변인 이유?
1. 캐싱 기능에 의한 메모리 절약과 속도 향상
- Java에서 String 객체들은 Heap의 String Pool 이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을수록 상당한 성능 향상을 기대할 수 있음

2. thread-safe
- String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전함

3. 보안기능
- 중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리함

## 접근 제한자(Access Modifier)에 대해 설명
변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미하며, 총 4가지 있음

- public : 접근 제한이 없음 (같은 프로젝트 내 어디서든 사용 가능)
- protected : 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능함
- (default) : 해당 패키지 내에서만 접근 가능
- private : 해당 클래스에서만 접근 가능

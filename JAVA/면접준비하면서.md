## JVM(Java Virtual Machine)
https://coding-factory.tistory.com/827

### 자바 프로그램 실행환경을 만들어 주는 소프트웨어

자바 코드 컴파일 .class 바이트 코드로 만들면 이 코드가 자바 가상 머신 환경에서 실행됨

JVM은 자바 실행 환경 JRE에 포함되어 있음

현재 사용하는 컴퓨터의 운영체제에 맞는 자바 실행환경 (JRE)가 설치되어 있다면 자바 가상 머신이 설치되어 있다는 뜻

***Java는 플랫폼에 종속적이지 않지만 JVM은 플랫폼에 종속적임***

Java는 컴파일된 ***바이트코드***로 어떤 JVM에서도 동작시킬 수 있기 때문에 플랫폼에 의존적이지 않다.

하지만 반대로 자바 가상머신(JVM)은 플랫폼에 의존적임

자바로 작성된 모든 프로그램은 자바 가상 머신에서만 실행될 수 있으므로, 자바 프로그램을 실행하기 위해서는 반드시 자바 가상 머신이

설치되어야함

## 원시 타입 vs 참조 타입
https://velog.io/@gillog/%EC%9B%90%EC%8B%9C%ED%83%80%EC%9E%85-%EC%B0%B8%EC%A1%B0%ED%83%80%EC%9E%85Primitive-Type-Reference-Type

원시 타입 : 정수, 실수, 무자, 논리 리터럴 등의 ***실제 데이터값*** 을 저장하는 타입

참조 타입 : 객체(Object)의 번지를 참조(주소를 저장)하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입 (문자열, 배열, 열거, 클래스, 인터페이스)

### 저장되는 곳
- 실제 객체 : 힙
- 참조 타입 변수 : 스택 영역에 객체들의 ***주소***를 저장, 객체의 주소를 불러와 사용하는 방식

### 참조 타입

- 정적 메모리 스택(Stack) 영역

스택 영역에는 기본타입 변수가 할당되고 변수의 실제 값들을 저장함

참조 타입의 변수들은 이 스택 영역에서 힙 영역에 생성된 객체들의 주소 값을 저장함

객체 안에 메소드의 작업이 종료되면 할당되었던 메모리 공간은 반환되어 비워짐

- 동적 메모리 힙(Heap) 영역

힙 영역에는 객체와 배열이 생성됨

그리고 참조타입(배열, 클래스, 인터페이스 등) 들이 이 객체들의 __주소__ 값을 저장하고 있음

기본타입 변수들과는 다르게 크기가 정해지지 않음

프로그램 실행시 메모리에 동적으로 할당됨

참조하는 변수가 없으면 자바의 __GC__가 제거함

### Boxing, Unboxing
- Boxing : 원시타입 -> 참조타입 변환
- Unboxing : 참조타입 -> 원시타입

### 원시타입과 참조타입 차이

- Null : 원시 x , 참조 o
~~~java
int i = null; // (x)

Integer integer = null; // (o)
~~~
- 제너릭 : 원시 x , 참조 o
~~~java
List<i> list; // (x)

List<Integer> list; // (o)
~~~

### 이렇게 알아보면 참조타입이 무조건 다 좋아보일수 있지만 원시타입의 장점은 따로 있음

### 원시타입 장점

- 접근 속도
원시타입은 '스택' 메모리에 값이 존재함

반면 참조타입은 하나의 인스턴스이기 때문에 '스택' 메모리에는 참조값만 있고, 실제 값은 힙 메모리에 존재함

그리고 값을 필요로 할 때마다 언박싱 과정을 거쳐야 하기에 원시타입과 비교해서 접근 속도가 느려짐 ( 매우 큰 숫자면 원시값이 나음 )


----------------------------------------------------------------------------------------------------

## static 변수와 static 메서드
https://dev-coco.tistory.com/23

### 정적(Static)
정적(static)은 고정된이란 의미를 가지고 있음

static이라는 키워드를 사용하여 static변수와 static메서드를 만들 수 있는 데 다른말로 ***정적필드***와 ***정적메서드*** 라고 하며,

이 둘을 합쳐 정적 멤버(= 클래스 멤버)라고 함

정적필드와 정작메서드는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버이기에 클래스 로더가 클래스를 로딩해서 메서드 메모리 영역에 적재할 때 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있음

- static 키워드를 통해 생성된 정적멤버들은 ***Heap***영역이 아닌 ***Static***영역에 할당됨
- Static영역에 할당된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점을 가지지만, Garbage Collector의 관리 영역 밖에 존재하기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재하게 됨
- 그렇기에 static을 남발하게되면 성능에 악영향을 줄 수 있음
